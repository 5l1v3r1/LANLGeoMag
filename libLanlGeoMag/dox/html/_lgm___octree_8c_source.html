<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LanlGeoMag: /home/mgh/LanlGeoMag/libLanlGeoMag/Lgm_Octree.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>/home/mgh/LanlGeoMag/libLanlGeoMag/Lgm_Octree.c</h1><a href="_lgm___octree_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include "<a class="code" href="_lgm___octree_8h.html">Lgm/Lgm_Octree.h</a>"</span>
<a name="l00002"></a>00002 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00003"></a>00003 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;sys/timeb.h&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
<a name="l00009"></a>00009 
<a name="l00010"></a><a class="code" href="_lgm___octree_8c.html#36c11daf675931ac69b5478131af8e27">00010</a> <span class="keyword">struct </span>timeb  <a class="code" href="_lgm___octree_8c.html#36c11daf675931ac69b5478131af8e27">StartTime</a>;
<a name="l00011"></a>00011 <span class="keywordtype">double</span> <a class="code" href="_lgm___octree_8c.html#c350804981295b42e11e3e5978df415f">ElapsedTime2</a>( <span class="keyword">struct</span> timeb <a class="code" href="_lgm___octree_8c.html#36c11daf675931ac69b5478131af8e27">StartTime</a> );
<a name="l00012"></a>00012 
<a name="l00013"></a><a class="code" href="_lgm___octree_8c.html#5be6ddcd43586ee6989697d995319c31">00013</a> <span class="keywordtype">void</span> <a class="code" href="_lgm___octree_8h.html#5be6ddcd43586ee6989697d995319c31">Binary</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *Str ) {
<a name="l00014"></a>00014     <span class="keywordtype">int</span>             i, j;
<a name="l00015"></a>00015     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    mask;
<a name="l00016"></a>00016     <span class="keywordflow">for</span> (j=0, i=15; i&gt;=0; i--, j++){
<a name="l00017"></a>00017         mask = 1&lt;&lt;i;
<a name="l00018"></a>00018         Str[j] = ( n &amp; mask ) ? <span class="charliteral">'1'</span> : <span class="charliteral">'0'</span>;
<a name="l00019"></a>00019         <span class="keywordflow">if</span> (j==7) Str[++j] = <span class="charliteral">' '</span>;
<a name="l00020"></a>00020     }
<a name="l00021"></a>00021     Str[j] = <span class="charliteral">'\0'</span>;
<a name="l00022"></a>00022 }
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment">/*</span>
<a name="l00028"></a>00028 <span class="comment"> *  Recursively free the entire octree</span>
<a name="l00029"></a>00029 <span class="comment"> */</span>
<a name="l00030"></a><a class="code" href="_lgm___octree_8c.html#ebbdef4a1addf536593f776187402c39">00030</a> <span class="keywordtype">void</span> <a class="code" href="_lgm___octree_8h.html#ebbdef4a1addf536593f776187402c39">Lgm_OctreeFreeBranch</a>( <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *Cell ){
<a name="l00031"></a>00031 
<a name="l00032"></a>00032     <span class="keywordtype">int</span> i;
<a name="l00033"></a>00033 
<a name="l00034"></a>00034     <span class="keywordflow">if</span> ( Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a> == NULL ) {
<a name="l00035"></a>00035 
<a name="l00036"></a>00036         <span class="comment">/*</span>
<a name="l00037"></a>00037 <span class="comment">         *  Then this is a leaf. Free its contents then return.</span>
<a name="l00038"></a>00038 <span class="comment">         */</span>
<a name="l00039"></a>00039         <span class="keywordflow">if</span> ( Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a> ) {
<a name="l00040"></a>00040             free( Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a> ); 
<a name="l00041"></a>00041             Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a> = NULL;
<a name="l00042"></a>00042         }
<a name="l00043"></a>00043 
<a name="l00044"></a>00044     } <span class="keywordflow">else</span> {
<a name="l00045"></a>00045 
<a name="l00046"></a>00046         <span class="keywordflow">for</span> (i=0; i&lt;8; ++i) <a class="code" href="_lgm___octree_8h.html#ebbdef4a1addf536593f776187402c39">Lgm_OctreeFreeBranch</a>( &amp;(Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a>[i]) );
<a name="l00047"></a>00047         free( Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a> );
<a name="l00048"></a>00048         Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a> = NULL;
<a name="l00049"></a>00049     
<a name="l00050"></a>00050     }
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 
<a name="l00053"></a>00053     <span class="keywordflow">return</span>;
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 }
<a name="l00057"></a>00057 
<a name="l00058"></a><a class="code" href="_lgm___octree_8c.html#8966fb8ec73aa1c0e437604568685d13">00058</a> <span class="keywordtype">void</span> <a class="code" href="_lgm___octree_8h.html#8966fb8ec73aa1c0e437604568685d13">Lgm_FreeOctree</a>( <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *ot ) {
<a name="l00059"></a>00059     <a class="code" href="_lgm___octree_8h.html#ebbdef4a1addf536593f776187402c39">Lgm_OctreeFreeBranch</a>( ot );
<a name="l00060"></a>00060     free( ot );
<a name="l00061"></a>00061 }
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 
<a name="l00064"></a><a class="code" href="_lgm___octree_8c.html#cf7917181ce8b3f4ceb3f8f6af804889">00064</a> <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *<a class="code" href="_lgm___octree_8h.html#cf7917181ce8b3f4ceb3f8f6af804889">Lgm_CreateOctreeRoot</a>( ) {
<a name="l00065"></a>00065 
<a name="l00066"></a>00066     <span class="keywordtype">char</span>            Str[20];
<a name="l00067"></a>00067     <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a>  *Cell;
<a name="l00068"></a>00068 
<a name="l00069"></a>00069     <span class="comment">/*</span>
<a name="l00070"></a>00070 <span class="comment">     * allocate </span>
<a name="l00071"></a>00071 <span class="comment">     */</span>
<a name="l00072"></a>00072     Cell = (<a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *) calloc( 1, <span class="keyword">sizeof</span>( <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> ) );
<a name="l00073"></a>00073     Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a> = 0;
<a name="l00074"></a>00074     Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#4adbef09447a8b0f9932cec8c5e507ee">Parent</a> = NULL;
<a name="l00075"></a>00075     Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a> = NULL;
<a name="l00076"></a>00076     Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#068d265e1d6fb7a08db0fd289db2b3ae">xLocationCode</a> = 0;
<a name="l00077"></a>00077     Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#fd9d41af65e45952ff7a6ec326f8ce86">yLocationCode</a> = 0;
<a name="l00078"></a>00078     Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#197011505d40af9f13649872c67a61e1">zLocationCode</a> = 0;
<a name="l00079"></a>00079     Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#a3d2c0758a70c3bb49a3d73a14a94d0a">Level</a> = <a class="code" href="_lgm___octree_8h.html#50cc89ad030d4d45cf6450bf67ab1a6a">OCTREE_ROOT_LEVEL</a>;
<a name="l00080"></a>00080     Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#8ee9be1b5aa75abae556de3088cba6d9">h</a> = 0.5;          <span class="comment">// Root Cell has cube with face half-width = 0.5</span>
<a name="l00081"></a>00081     Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#6db57193d204ce24705e3e95a23bc7c1">Center</a>.<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a> = 0.5;   <span class="comment">// Center is at (0.5, 0.5, 0.5)</span>
<a name="l00082"></a>00082     Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#6db57193d204ce24705e3e95a23bc7c1">Center</a>.<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a> = 0.5;
<a name="l00083"></a>00083     Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#6db57193d204ce24705e3e95a23bc7c1">Center</a>.<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a> = 0.5;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="comment">//    Binary( Cell-&gt;xLocationCode, Str ); printf("Root  xLocationCode = %s\n", Str);</span>
<a name="l00086"></a>00086 <span class="comment">//    Binary( Cell-&gt;yLocationCode, Str ); printf("Root  yLocationCode = %s\n", Str);</span>
<a name="l00087"></a>00087 <span class="comment">//    Binary( Cell-&gt;zLocationCode, Str ); printf("Root  zLocationCode = %s\n\n", Str);</span>
<a name="l00088"></a>00088 
<a name="l00089"></a>00089     <span class="keywordflow">return</span>( Cell );
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 
<a name="l00099"></a><a class="code" href="_lgm___octree_8c.html#9b05a3600cfb54efc5f722928e1db5d4">00099</a> <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *<a class="code" href="_lgm___octree_8h.html#9b05a3600cfb54efc5f722928e1db5d4">Lgm_OctreeTraverseToLocCode</a>( <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *Cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ChildLevel, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xLocationCode, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> yLocationCode, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> zLocationCode ) {
<a name="l00100"></a>00100 
<a name="l00101"></a>00101     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    BranchBit, Index;
<a name="l00102"></a>00102 
<a name="l00103"></a>00103     <span class="keywordflow">while</span>( Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a> ) { <span class="comment">// loop until we reach a leaf (i.e. until Octant is NULL)</span>
<a name="l00104"></a>00104 
<a name="l00105"></a>00105         <span class="comment">// set branch bit for the children of Cell</span>
<a name="l00106"></a>00106         BranchBit  = 1&lt;&lt;ChildLevel; 
<a name="l00107"></a>00107 
<a name="l00108"></a>00108         <span class="comment">// determine which octant to enter</span>
<a name="l00109"></a>00109         Index = (((xLocationCode &amp; BranchBit) &gt;&gt; ChildLevel) 
<a name="l00110"></a>00110                         + 2*( ((yLocationCode &amp; BranchBit) &gt;&gt; ChildLevel) 
<a name="l00111"></a>00111                             + 2*((zLocationCode &amp; BranchBit) &gt;&gt; ChildLevel) ) );
<a name="l00112"></a>00112 
<a name="l00113"></a>00113         Cell = &amp;(Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a>[Index]);
<a name="l00114"></a>00114         --ChildLevel;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116     }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118     <span class="keywordflow">return</span>( Cell );
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="comment">/*</span>
<a name="l00125"></a>00125 <span class="comment"> * This returns a pointer to the cell that contains the query point</span>
<a name="l00126"></a>00126 <span class="comment"> */</span>
<a name="l00127"></a><a class="code" href="_lgm___octree_8c.html#271dd512841a7b4308c59db95853b8e1">00127</a> <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *<a class="code" href="_lgm___octree_8h.html#271dd512841a7b4308c59db95853b8e1">Lgm_LocateNearestCell</a>( <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *Root, <a class="code" href="struct_lgm___vector.html">Lgm_Vector</a> *q ){
<a name="l00128"></a>00128 
<a name="l00129"></a>00129     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    xLocationCode = (<span class="keywordtype">unsigned</span> int)(q-&gt;<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a> * <a class="code" href="_lgm___octree_8h.html#840a13e4ac67b3dece56d79c7ff99b59">OCTREE_MAX_VAL</a>);
<a name="l00130"></a>00130     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    yLocationCode = (<span class="keywordtype">unsigned</span> int)(q-&gt;<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a> * <a class="code" href="_lgm___octree_8h.html#840a13e4ac67b3dece56d79c7ff99b59">OCTREE_MAX_VAL</a>);
<a name="l00131"></a>00131     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    zLocationCode = (<span class="keywordtype">unsigned</span> int)(q-&gt;<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a> * <a class="code" href="_lgm___octree_8h.html#840a13e4ac67b3dece56d79c7ff99b59">OCTREE_MAX_VAL</a>);
<a name="l00132"></a>00132     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    ChildLevel;
<a name="l00133"></a>00133     <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a>  *Cell, *Result;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     Cell       = Root;
<a name="l00136"></a>00136     ChildLevel = Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#a3d2c0758a70c3bb49a3d73a14a94d0a">Level</a> - 1;
<a name="l00137"></a>00137     Result     = <a class="code" href="_lgm___octree_8h.html#9b05a3600cfb54efc5f722928e1db5d4">Lgm_OctreeTraverseToLocCode</a>( Cell, ChildLevel, xLocationCode, yLocationCode, zLocationCode );
<a name="l00138"></a>00138 
<a name="l00139"></a>00139     <span class="keywordflow">return</span>( Result );
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 }
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <span class="comment">/*</span>
<a name="l00158"></a>00158 <span class="comment"> * This routine computes the minimum distance between a point and a cube.</span>
<a name="l00159"></a>00159 <span class="comment"> * The dimensions and center of the cube are stored in the Lgm_OctreeCell</span>
<a name="l00160"></a>00160 <span class="comment"> * structure.</span>
<a name="l00161"></a>00161 <span class="comment"> */</span>
<a name="l00162"></a><a class="code" href="_lgm___octree_8c.html#07152ce3d1254cca2f4f2d4735de34b7">00162</a> <span class="keywordtype">double</span>  <a class="code" href="_lgm___octree_8h.html#07152ce3d1254cca2f4f2d4735de34b7">MinDist</a>( <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *Cell, <a class="code" href="struct_lgm___vector.html">Lgm_Vector</a> *q ) {
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     <span class="keywordtype">double</span>  px, py, pz, d, ph, mh, distance2 = 0.0;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166     ph  = Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#8ee9be1b5aa75abae556de3088cba6d9">h</a>;  <span class="comment">// + half width of a cube face</span>
<a name="l00167"></a>00167     mh  = -ph;      <span class="comment">// - half width of a cube face</span>
<a name="l00168"></a>00168 
<a name="l00169"></a>00169     <span class="comment">// assume cube is centered at origin, by shifting query point.</span>
<a name="l00170"></a>00170     <span class="comment">// i.e. transform point into frame where cube is centered at origin</span>
<a name="l00171"></a>00171     px = q-&gt;<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a> - Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#6db57193d204ce24705e3e95a23bc7c1">Center</a>.<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a>;
<a name="l00172"></a>00172     py = q-&gt;<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a> - Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#6db57193d204ce24705e3e95a23bc7c1">Center</a>.<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a>;
<a name="l00173"></a>00173     pz = q-&gt;<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a> - Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#6db57193d204ce24705e3e95a23bc7c1">Center</a>.<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a>;
<a name="l00174"></a>00174 <span class="comment">//printf("MinDist(): q = %g %g %g\n", q-&gt;x, q-&gt;y, q-&gt;z );</span>
<a name="l00175"></a>00175     
<a name="l00176"></a>00176     <span class="keywordflow">if</span>      ( px &lt; mh ) { d = px+ph; distance2 += d*d; }
<a name="l00177"></a>00177     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( px &gt; ph ) { d = px-ph; distance2 += d*d; }
<a name="l00178"></a>00178 
<a name="l00179"></a>00179     <span class="keywordflow">if</span>      ( py &lt; mh ) { d = py+ph; distance2 += d*d; }
<a name="l00180"></a>00180     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( py &gt; ph ) { d = py-ph; distance2 += d*d; }
<a name="l00181"></a>00181 
<a name="l00182"></a>00182     <span class="keywordflow">if</span>      ( pz &lt; mh ) { d = pz+ph; distance2 += d*d; }
<a name="l00183"></a>00183     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( pz &gt; ph ) { d = pz-ph; distance2 += d*d; }
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 <span class="comment">//printf("MinDist(): distance2 = %g\n", distance2);</span>
<a name="l00186"></a>00186     <span class="keywordflow">return</span>( distance2 );
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="comment">/*</span>
<a name="l00194"></a>00194 <span class="comment"> *  Insert a Cell object into the Priority Queue (PQ). This computes distance</span>
<a name="l00195"></a>00195 <span class="comment"> *  and puts it into the PQ at the right place to maintain a `mindist' order</span>
<a name="l00196"></a>00196 <span class="comment"> *  (the top object of the queue.</span>
<a name="l00197"></a>00197 <span class="comment"> */</span>
<a name="l00198"></a><a class="code" href="_lgm___octree_8c.html#cb735b055954d17d224db5a55dbd14e6">00198</a> <span class="keywordtype">double</span> <a class="code" href="_lgm___octree_8h.html#cb735b055954d17d224db5a55dbd14e6">InsertCell</a>( <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *Cell, <a class="code" href="struct_lgm___vector.html">Lgm_Vector</a> *q, <a class="code" href="struct__p_queue.html">pQueue</a> **PQ, <span class="keywordtype">double</span> MaxDist2 ) {
<a name="l00199"></a>00199 
<a name="l00200"></a>00200     <span class="keywordtype">int</span>     done, InsertAtEnd;
<a name="l00201"></a>00201     <span class="keywordtype">double</span>  dist;
<a name="l00202"></a>00202     <a class="code" href="struct__p_queue.html">pQueue</a>  *<span class="keyword">new</span>, *p;
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 
<a name="l00205"></a>00205     <span class="comment">/*</span>
<a name="l00206"></a>00206 <span class="comment">     * If the cell's MinDist2 &gt; MaxDist2, then we should just ignore</span>
<a name="l00207"></a>00207 <span class="comment">     * the entire cell becuase none of its contents can possibly have points</span>
<a name="l00208"></a>00208 <span class="comment">     * that are &lt; MaxDist2</span>
<a name="l00209"></a>00209 <span class="comment">     */</span>
<a name="l00210"></a>00210     dist = <a class="code" href="_lgm___octree_8h.html#07152ce3d1254cca2f4f2d4735de34b7">MinDist</a>( Cell, q );
<a name="l00211"></a>00211     <span class="keywordflow">if</span> ( dist &gt; MaxDist2 ) <span class="keywordflow">return</span>(9e99);
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 
<a name="l00214"></a>00214 
<a name="l00215"></a>00215     <span class="comment">// Allocate an element for the PQ</span>
<a name="l00216"></a>00216     <span class="keyword">new</span> = (<a class="code" href="struct__p_queue.html">pQueue</a> *) calloc( 1, <span class="keyword">sizeof</span>(<a class="code" href="struct__p_queue.html">pQueue</a>) );
<a name="l00217"></a>00217 
<a name="l00218"></a>00218     <span class="comment">// Add Info</span>
<a name="l00219"></a>00219     <span class="keyword">new</span>-&gt;Obj      = Cell;
<a name="l00220"></a>00220     <span class="keyword">new</span>-&gt;MinDist2 = dist;
<a name="l00221"></a>00221 <span class="comment">//printf("InsertCell: MinDist2 = %g   Level = %d\n", dist, Cell-&gt;Level);</span>
<a name="l00222"></a>00222     <span class="keyword">new</span>-&gt;IsPoint  = <a class="code" href="_lgm___c_trans_8h.html#a93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l00223"></a>00223 
<a name="l00224"></a>00224     <span class="keywordflow">if</span> ( *PQ == NULL ) {
<a name="l00225"></a>00225         <span class="comment">// nothing in the Priority Queue.</span>
<a name="l00226"></a>00226         *PQ = <span class="keyword">new</span>;
<a name="l00227"></a>00227     <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a> = NULL;
<a name="l00228"></a>00228     <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a> = NULL;
<a name="l00229"></a>00229         <span class="keywordflow">return</span>( dist );
<a name="l00230"></a>00230     } <span class="keywordflow">else</span> {
<a name="l00231"></a>00231 
<a name="l00232"></a>00232         <span class="comment">// find where to add the new element</span>
<a name="l00233"></a>00233         p = *PQ;
<a name="l00234"></a>00234         done = <a class="code" href="_lgm___c_trans_8h.html#a93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l00235"></a>00235         InsertAtEnd = <a class="code" href="_lgm___c_trans_8h.html#a93f0eb578d23995850d61f7d61c55c1">FALSE</a>; <span class="comment">// always insert new object before the object pointed at by p unless this is true</span>
<a name="l00236"></a>00236                  <span class="comment">// then it goes at the end.</span>
<a name="l00237"></a>00237         <span class="keywordflow">while</span> ( !done ) {
<a name="l00238"></a>00238             <span class="keywordflow">if</span> ( new-&gt;MinDist2 &lt;= p-&gt;<a class="code" href="struct__p_queue.html#fcb495567b98cde535c5239b17681f62">MinDist2</a> ) {
<a name="l00239"></a>00239                 done = <a class="code" href="_lgm___c_trans_8h.html#a8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00240"></a>00240             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( p-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a> == NULL ) {
<a name="l00241"></a>00241                 done = <a class="code" href="_lgm___c_trans_8h.html#a8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00242"></a>00242                 InsertAtEnd = <a class="code" href="_lgm___c_trans_8h.html#a8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00243"></a>00243             } <span class="keywordflow">else</span> {
<a name="l00244"></a>00244                 p = p-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a>;
<a name="l00245"></a>00245             }
<a name="l00246"></a>00246         }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 
<a name="l00249"></a>00249         <span class="comment">//if ( p == NULL ) {</span>
<a name="l00250"></a>00250         <span class="keywordflow">if</span> ( InsertAtEnd ) {
<a name="l00251"></a>00251             <span class="comment">// Insert at bottom (i.e. as last element)</span>
<a name="l00252"></a>00252             p-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a>   = <span class="keyword">new</span>;
<a name="l00253"></a>00253             <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a> = NULL;
<a name="l00254"></a>00254             <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a> = p;
<a name="l00255"></a>00255         } <span class="keywordflow">else</span> {
<a name="l00256"></a>00256             <span class="keywordflow">if</span> ( p-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a> == NULL ) {
<a name="l00257"></a>00257                 <span class="comment">// Insert at top (i.e. as first element)</span>
<a name="l00258"></a>00258                 <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a> = p;
<a name="l00259"></a>00259                 <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a> = NULL;
<a name="l00260"></a>00260                 p-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a>   = <span class="keyword">new</span>;
<a name="l00261"></a>00261                 *PQ        = <span class="keyword">new</span>;
<a name="l00262"></a>00262             } <span class="keywordflow">else</span> {
<a name="l00263"></a>00263                 <span class="comment">// Insert before p</span>
<a name="l00264"></a>00264                 <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a>     = p;
<a name="l00265"></a>00265                 <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a>     = p-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a>;
<a name="l00266"></a>00266                 p-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a>-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a> = <span class="keyword">new</span>;
<a name="l00267"></a>00267                 p-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a>       = <span class="keyword">new</span>;
<a name="l00268"></a>00268             }
<a name="l00269"></a>00269         }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271     }
<a name="l00272"></a>00272 
<a name="l00273"></a>00273     <span class="keywordflow">return</span>( dist );
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 <span class="comment">/*</span>
<a name="l00279"></a>00279 <span class="comment"> *  Insert a point object into the PQ</span>
<a name="l00280"></a>00280 <span class="comment"> *  This computes distance and puts it into the PQ at the right place.</span>
<a name="l00281"></a>00281 <span class="comment"> */</span>
<a name="l00282"></a><a class="code" href="_lgm___octree_8c.html#0128a077b1023c02e79cfaf65a4e6cfc">00282</a> <span class="keywordtype">void</span> <a class="code" href="_lgm___octree_8h.html#0128a077b1023c02e79cfaf65a4e6cfc">InsertPoint</a>( <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *Cell, <span class="keywordtype">int</span> j, <a class="code" href="struct_lgm___vector.html">Lgm_Vector</a> *q, <a class="code" href="struct__p_queue.html">pQueue</a> **PQ ) {
<a name="l00283"></a>00283 
<a name="l00284"></a>00284     <a class="code" href="struct__p_queue.html">pQueue</a>  *<span class="keyword">new</span>, *p;
<a name="l00285"></a>00285     <span class="keywordtype">double</span>  x, y, z, dx, dy, dz, MinDist2 = 0.0;
<a name="l00286"></a>00286 
<a name="l00287"></a>00287     <span class="comment">// compute distance^2 between point and query point</span>
<a name="l00288"></a>00288     x = Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a>; dx = q-&gt;<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a>-x; MinDist2 += dx*dx;
<a name="l00289"></a>00289     y = Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a>; dy = q-&gt;<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a>-y; MinDist2 += dy*dy;
<a name="l00290"></a>00290     z = Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a>; dz = q-&gt;<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a>-z; MinDist2 += dz*dz;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292     
<a name="l00293"></a>00293 
<a name="l00294"></a>00294 
<a name="l00295"></a>00295     <span class="comment">// Allocate an element for the PQ</span>
<a name="l00296"></a>00296     <span class="keyword">new</span> = (<a class="code" href="struct__p_queue.html">pQueue</a> *) calloc( 1, <span class="keyword">sizeof</span>(<a class="code" href="struct__p_queue.html">pQueue</a>) );
<a name="l00297"></a>00297 
<a name="l00298"></a>00298     <span class="comment">// Add Info</span>
<a name="l00299"></a>00299     <span class="keyword">new</span>-&gt;Obj      = Cell;
<a name="l00300"></a>00300     <span class="keyword">new</span>-&gt;MinDist2 = MinDist2;
<a name="l00301"></a>00301 <span class="comment">//printf("InsertPoint: MinDist2 = %g\n", MinDist2);</span>
<a name="l00302"></a>00302     <span class="keyword">new</span>-&gt;IsPoint  = <a class="code" href="_lgm___c_trans_8h.html#a8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00303"></a>00303     <span class="keyword">new</span>-&gt;j        = j;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305     <span class="keywordflow">if</span> ( *PQ == NULL ) {
<a name="l00306"></a>00306         <span class="comment">// nothing in the Priority Queue.</span>
<a name="l00307"></a>00307         *PQ = <span class="keyword">new</span>;
<a name="l00308"></a>00308         <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a> = NULL;
<a name="l00309"></a>00309         <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a> = NULL;
<a name="l00310"></a>00310         <span class="keywordflow">return</span>;
<a name="l00311"></a>00311     } <span class="keywordflow">else</span> {
<a name="l00312"></a>00312         <span class="comment">// find where to add the new element</span>
<a name="l00313"></a>00313         p = *PQ;
<a name="l00314"></a>00314         <span class="keywordflow">while</span> ( p ) {
<a name="l00315"></a>00315             <span class="keywordflow">if</span> ( new-&gt;MinDist2 &lt; p-&gt;<a class="code" href="struct__p_queue.html#fcb495567b98cde535c5239b17681f62">MinDist2</a> ) {
<a name="l00316"></a>00316                 <span class="keywordflow">if</span> ( p-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a> == NULL ) {
<a name="l00317"></a>00317                     <span class="comment">// Insert at top (i.e. as first element)</span>
<a name="l00318"></a>00318                     <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a> = p;
<a name="l00319"></a>00319                     <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a> = NULL;
<a name="l00320"></a>00320                     p-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a>   = <span class="keyword">new</span>;
<a name="l00321"></a>00321                     *PQ        = <span class="keyword">new</span>;
<a name="l00322"></a>00322                     <span class="keywordflow">return</span>;
<a name="l00323"></a>00323                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( p-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a> == NULL ) {
<a name="l00324"></a>00324                     <span class="comment">// Insert at bottom (i.e. as last element)</span>
<a name="l00325"></a>00325                     p-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a>   = <span class="keyword">new</span>;
<a name="l00326"></a>00326                     <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a> = NULL;
<a name="l00327"></a>00327                     <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a> = p;
<a name="l00328"></a>00328                     <span class="keywordflow">return</span>;
<a name="l00329"></a>00329                 } <span class="keywordflow">else</span> {
<a name="l00330"></a>00330                     <span class="comment">// Insert before p</span>
<a name="l00331"></a>00331                     <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a>     = p;
<a name="l00332"></a>00332                     <span class="keyword">new</span>-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a>     = p-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a>;
<a name="l00333"></a>00333                     p-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a>-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a> = <span class="keyword">new</span>;
<a name="l00334"></a>00334                     p-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a>       = <span class="keyword">new</span>;
<a name="l00335"></a>00335                     <span class="keywordflow">return</span>;
<a name="l00336"></a>00336                 }
<a name="l00337"></a>00337             }
<a name="l00338"></a>00338             p = p-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a>;
<a name="l00339"></a>00339         }
<a name="l00340"></a>00340     }
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 
<a name="l00343"></a>00343 }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <span class="comment">/*</span>
<a name="l00348"></a>00348 <span class="comment"> *   Descend to the leaf that is closest to the query point</span>
<a name="l00349"></a>00349 <span class="comment"> */</span>
<a name="l00350"></a><a class="code" href="_lgm___octree_8c.html#9ff86b033bf330695e810d00ac8022e1">00350</a> <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *<a class="code" href="_lgm___octree_8h.html#9ff86b033bf330695e810d00ac8022e1">DescendTowardClosestLeaf</a>( <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *Node, <a class="code" href="struct__p_queue.html">pQueue</a> **PQ, <a class="code" href="struct_lgm___vector.html">Lgm_Vector</a> *q, <span class="keywordtype">double</span> MaxDist2 ) {
<a name="l00351"></a>00351 
<a name="l00352"></a>00352     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>   j;
<a name="l00353"></a>00353     <span class="keywordtype">double</span>              dist, min_dist;
<a name="l00354"></a>00354     <span class="keywordtype">int</span>                 i, min_i;
<a name="l00355"></a>00355     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        ChildLevel, BranchBit, Index;
<a name="l00356"></a>00356     <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a>     *Cell, *Result;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358     Cell = Node;
<a name="l00359"></a>00359     ChildLevel = Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#a3d2c0758a70c3bb49a3d73a14a94d0a">Level</a> - 1;
<a name="l00360"></a>00360 
<a name="l00361"></a>00361     
<a name="l00362"></a>00362 <span class="comment">//    while( Cell-&gt;Octant ) { // loop until we reach a leaf (i.e. until Octant is NULL)</span>
<a name="l00363"></a>00363     <span class="keywordflow">if</span> ( Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a> ) { <span class="comment">// do this if its a leaf cell</span>
<a name="l00364"></a>00364 
<a name="l00365"></a>00365         min_dist = 9e99;
<a name="l00366"></a>00366         min_i    = 0;
<a name="l00367"></a>00367         <span class="keywordflow">for</span> (i=0; i&lt;8; i++){
<a name="l00368"></a>00368 
<a name="l00369"></a>00369             <span class="comment">// Add Cell to Priority Queue</span>
<a name="l00370"></a>00370             dist = <a class="code" href="_lgm___octree_8h.html#cb735b055954d17d224db5a55dbd14e6">InsertCell</a>( &amp;(Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a>[i]), q, PQ, MaxDist2 );
<a name="l00371"></a>00371             
<a name="l00372"></a>00372             <span class="comment">// keep track of closest octant</span>
<a name="l00373"></a>00373             <span class="keywordflow">if</span> (dist &lt;= min_dist) {
<a name="l00374"></a>00374                 min_dist = dist;
<a name="l00375"></a>00375 <span class="comment">//printf("HHHHHHH: min_dist = %g\n", min_dist);</span>
<a name="l00376"></a>00376                 min_i    = i;
<a name="l00377"></a>00377             }
<a name="l00378"></a>00378             
<a name="l00379"></a>00379         }
<a name="l00380"></a>00380         
<a name="l00381"></a>00381         Cell = &amp;(Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a>[min_i]);
<a name="l00382"></a>00382 
<a name="l00383"></a>00383     } <span class="keywordflow">else</span> {
<a name="l00384"></a>00384 
<a name="l00385"></a>00385         <span class="comment">// Add point(s) (if any) to Priority Queue</span>
<a name="l00386"></a>00386         <span class="keywordflow">for</span> (j=0; j&lt;Cell-&gt;<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a>; j++){
<a name="l00387"></a>00387             <a class="code" href="_lgm___octree_8h.html#0128a077b1023c02e79cfaf65a4e6cfc">InsertPoint</a>( Cell, j, q, PQ );
<a name="l00388"></a>00388         }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390     }
<a name="l00391"></a>00391 
<a name="l00392"></a>00392     <span class="keywordflow">return</span>( Cell );
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 }
<a name="l00395"></a>00395 
<a name="l00396"></a>00396 <span class="comment">/*</span>
<a name="l00397"></a>00397 <span class="comment"> *  Print contents of priority Queue (for debugging)</span>
<a name="l00398"></a>00398 <span class="comment"> */</span>
<a name="l00399"></a><a class="code" href="_lgm___octree_8c.html#577327ba4885c8a45805115c03e606bd">00399</a> <span class="keywordtype">void</span> <a class="code" href="_lgm___octree_8c.html#577327ba4885c8a45805115c03e606bd">PrintPQ</a>( <a class="code" href="struct__p_queue.html">pQueue</a> **PQ ) {
<a name="l00400"></a>00400  
<a name="l00401"></a>00401     <span class="keywordtype">long</span> <span class="keywordtype">int</span>    i=0;
<a name="l00402"></a>00402     <a class="code" href="struct__p_queue.html">pQueue</a>      *p;
<a name="l00403"></a>00403 
<a name="l00404"></a>00404     p = *PQ;
<a name="l00405"></a>00405 
<a name="l00406"></a>00406     printf(<span class="stringliteral">"---- Contents of Priority Queue  ---------\n"</span>);
<a name="l00407"></a>00407     <span class="keywordflow">while</span> ( p != NULL ) {
<a name="l00408"></a>00408 
<a name="l00409"></a>00409     <span class="keywordflow">if</span> ( p-&gt;<a class="code" href="struct__p_queue.html#270a4dbd002743db25f63825195e4006">IsPoint</a> ) {
<a name="l00410"></a>00410         printf(<span class="stringliteral">"Item # %03ld  Point: MinDist2 = %g\n"</span>, i++, p-&gt;<a class="code" href="struct__p_queue.html#fcb495567b98cde535c5239b17681f62">MinDist2</a>);
<a name="l00411"></a>00411     } <span class="keywordflow">else</span> {
<a name="l00412"></a>00412         printf(<span class="stringliteral">"Item # %03ld   Cell: MinDist2 = %g\n"</span>, i++, p-&gt;<a class="code" href="struct__p_queue.html#fcb495567b98cde535c5239b17681f62">MinDist2</a>);
<a name="l00413"></a>00413     }
<a name="l00414"></a>00414     p = p-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a>;
<a name="l00415"></a>00415 
<a name="l00416"></a>00416     }
<a name="l00417"></a>00417     printf(<span class="stringliteral">"\n\n"</span>);
<a name="l00418"></a>00418 }
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 <span class="comment">/*</span>
<a name="l00421"></a>00421 <span class="comment"> *  Pop an Object off the top of the PQ</span>
<a name="l00422"></a>00422 <span class="comment"> */</span>
<a name="l00423"></a><a class="code" href="_lgm___octree_8c.html#653f08b2912abb5a5fb6c1761b8a8cec">00423</a> <a class="code" href="struct__p_queue.html">pQueue</a> *<a class="code" href="_lgm___octree_8h.html#653f08b2912abb5a5fb6c1761b8a8cec">PopObj</a>( <a class="code" href="struct__p_queue.html">pQueue</a> **PQ ) {
<a name="l00424"></a>00424 
<a name="l00425"></a>00425     <a class="code" href="struct__p_queue.html">pQueue</a> *p;
<a name="l00426"></a>00426 
<a name="l00427"></a>00427     p = *PQ;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429     <span class="keywordflow">if</span> ( p != NULL ) {
<a name="l00430"></a>00430         <span class="keywordflow">if</span> ( p-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a> != NULL ) {
<a name="l00431"></a>00431             *PQ = p-&gt;<a class="code" href="struct__p_queue.html#3a316f1387f6ede290905c4d79962b17">Next</a>;
<a name="l00432"></a>00432             (*PQ)-&gt;<a class="code" href="struct__p_queue.html#4717220aafe87eeda3986b3a258a2a2a">Prev</a> = NULL;
<a name="l00433"></a>00433         } <span class="keywordflow">else</span> {
<a name="l00434"></a>00434             *PQ = NULL;
<a name="l00435"></a>00435         }
<a name="l00436"></a>00436     }
<a name="l00437"></a>00437 
<a name="l00438"></a>00438     <span class="keywordflow">return</span>( p );
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 }
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 
<a name="l00444"></a>00444 <span class="comment">/*</span>
<a name="l00445"></a>00445 <span class="comment"> *  kNN: Finds the k Nearest Neighbors (kNN) of a query point q given that the</span>
<a name="l00446"></a>00446 <span class="comment"> *       set of data is stored as an Octree. All distances are in the normalized </span>
<a name="l00447"></a>00447 <span class="comment"> *       units (i.e. scaled from [0.0-1.0] ).</span>
<a name="l00448"></a>00448 <span class="comment"> *</span>
<a name="l00449"></a>00449 <span class="comment"> *</span>
<a name="l00450"></a>00450 <span class="comment"> *</span>
<a name="l00451"></a>00451 <span class="comment"> *  Input:</span>
<a name="l00452"></a>00452 <span class="comment"> *  ------</span>
<a name="l00453"></a>00453 <span class="comment"> *          q        - query position. I.e. the point we want to find NNs for.</span>
<a name="l00454"></a>00454 <span class="comment"> *          Root     - Root node of Octree.</span>
<a name="l00455"></a>00455 <span class="comment"> *          K        - Number of NNs to find.</span>
<a name="l00456"></a>00456 <span class="comment"> *          MaxDist2 - Threshold distance^2 beyond which we give up on finding</span>
<a name="l00457"></a>00457 <span class="comment"> *                      NNs.  (i.e. could find them, but we arent interested</span>
<a name="l00458"></a>00458 <span class="comment"> *                      because they'd be too far from our query point to be</span>
<a name="l00459"></a>00459 <span class="comment"> *                      useful).</span>
<a name="l00460"></a>00460 <span class="comment"> *  Output:</span>
<a name="l00461"></a>00461 <span class="comment"> *  -------</span>
<a name="l00462"></a>00462 <span class="comment"> *          Kgot     - Number of NNs (within MaxDist2) that we actually found.</span>
<a name="l00463"></a>00463 <span class="comment"> *          kNN      - List of kNN Data items. Sorted (closest first).</span>
<a name="l00464"></a>00464 <span class="comment"> *</span>
<a name="l00465"></a>00465 <span class="comment"> *  Return Value:</span>
<a name="l00466"></a>00466 <span class="comment"> *  --------------</span>
<a name="l00467"></a>00467 <span class="comment"> *          OCTREE_KNN_SUCCESS         - Search succeeded.</span>
<a name="l00468"></a>00468 <span class="comment"> *          OCTREE_KNN_TOO_FEW_NNS     - Search terminated because we couldnt find </span>
<a name="l00469"></a>00469 <span class="comment">                                         K NNs that were close enough.</span>
<a name="l00470"></a>00470 <span class="comment"> *          OCTREE_KNN_NOT_ENOUGH_DATA - Octree doesnt contain enough data points.</span>
<a name="l00471"></a>00471 <span class="comment"> *</span>
<a name="l00472"></a>00472 <span class="comment"> *</span>
<a name="l00473"></a>00473 <span class="comment"> */</span>
<a name="l00474"></a><a class="code" href="_lgm___octree_8c.html#885f0695706ada1ee750180afe105958">00474</a> <span class="keywordtype">int</span> <a class="code" href="_lgm___octree_8h.html#885f0695706ada1ee750180afe105958">Lgm_Octree_kNN</a>( <a class="code" href="struct_lgm___vector.html">Lgm_Vector</a> *q, <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *Root, <span class="keywordtype">int</span> K, <span class="keywordtype">int</span> *Kgot, <span class="keywordtype">double</span> MaxDist2, <a class="code" href="struct___lgm___octree_data.html">Lgm_OctreeData</a> *kNN ) {
<a name="l00475"></a>00475 
<a name="l00476"></a>00476     <span class="keywordtype">int</span>         k, done;
<a name="l00477"></a>00477     <a class="code" href="struct__p_queue.html">pQueue</a>      *PQ, *p;
<a name="l00478"></a>00478 
<a name="l00479"></a>00479     *Kgot = 0;
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="comment">//MaxDist2 = .05;</span>
<a name="l00482"></a>00482 
<a name="l00483"></a>00483     <span class="comment">/*</span>
<a name="l00484"></a>00484 <span class="comment">     * Check to see if there are enough points.</span>
<a name="l00485"></a>00485 <span class="comment">     * Bailout with error flag -1 if not.</span>
<a name="l00486"></a>00486 <span class="comment">     */</span>
<a name="l00487"></a>00487     <span class="keywordflow">if</span> (Root-&gt;<a class="code" href="struct___lgm___octree_cell.html#783709cb5c4b14570bf342099817323d">nDataBelow</a> &lt; K ) <span class="keywordflow">return</span>( <a class="code" href="_lgm___octree_8h.html#2a18af7173f980bc48f9184d3258b502">OCTREE_KNN_NOT_ENOUGH_DATA</a> );
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 
<a name="l00490"></a>00490     <span class="comment">/*</span>
<a name="l00491"></a>00491 <span class="comment">     *  Add Root Node to the Priority Queue.</span>
<a name="l00492"></a>00492 <span class="comment">     */</span>
<a name="l00493"></a>00493     PQ = NULL;
<a name="l00494"></a>00494     <a class="code" href="_lgm___octree_8h.html#cb735b055954d17d224db5a55dbd14e6">InsertCell</a>( Root, q, &amp;PQ, MaxDist2 );
<a name="l00495"></a>00495 
<a name="l00496"></a>00496     <span class="comment">/*</span>
<a name="l00497"></a>00497 <span class="comment">     *  Process items on the Priority Queue until we are done.</span>
<a name="l00498"></a>00498 <span class="comment">     */</span>
<a name="l00499"></a>00499     k    = 0;       <span class="comment">// havent found any NNs yet.</span>
<a name="l00500"></a>00500     done = <a class="code" href="_lgm___c_trans_8h.html#a93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l00501"></a>00501     <span class="keywordflow">while</span>( !done ) {
<a name="l00502"></a>00502 
<a name="l00503"></a>00503     <span class="comment">//PrintPQ( &amp;PQ ); //only for debugging</span>
<a name="l00504"></a>00504 
<a name="l00505"></a>00505         <span class="comment">/*</span>
<a name="l00506"></a>00506 <span class="comment">         * Pop the highest priority item off of the Priority Queue.</span>
<a name="l00507"></a>00507 <span class="comment">         * This is the closest object to the query point. Note that</span>
<a name="l00508"></a>00508 <span class="comment">         * it could be a cell or it could be a point.</span>
<a name="l00509"></a>00509 <span class="comment">         */</span>
<a name="l00510"></a>00510         p = <a class="code" href="_lgm___octree_8h.html#653f08b2912abb5a5fb6c1761b8a8cec">PopObj</a>( &amp;PQ );
<a name="l00511"></a>00511 
<a name="l00512"></a>00512         <span class="keywordflow">if</span> ( p ) {
<a name="l00513"></a>00513 
<a name="l00514"></a>00514             <span class="keywordflow">if</span> ( p-&gt;<a class="code" href="struct__p_queue.html#270a4dbd002743db25f63825195e4006">IsPoint</a> ) {
<a name="l00515"></a>00515                 <span class="comment">/*</span>
<a name="l00516"></a>00516 <span class="comment">                 * Since a point is now the closest object, it must be one of</span>
<a name="l00517"></a>00517 <span class="comment">                 * the kNN.  But, if its too far away, then we are done with</span>
<a name="l00518"></a>00518 <span class="comment">                 * the search -- we couldnt find K NNs close enough to the</span>
<a name="l00519"></a>00519 <span class="comment">                 * query point</span>
<a name="l00520"></a>00520 <span class="comment">                 */</span>
<a name="l00521"></a>00521                 <span class="keywordflow">if</span> ( p-&gt;<a class="code" href="struct__p_queue.html#fcb495567b98cde535c5239b17681f62">MinDist2</a> &gt; MaxDist2 ) {
<a name="l00522"></a>00522                     <span class="keywordflow">while</span> ( (p = <a class="code" href="_lgm___octree_8h.html#653f08b2912abb5a5fb6c1761b8a8cec">PopObj</a>(&amp;PQ)) ) free( p );
<a name="l00523"></a>00523                     <span class="keywordflow">return</span>( <a class="code" href="_lgm___octree_8h.html#b5ea4768ba7862b8601a3ef27d6843f0">OCTREE_KNN_TOO_FEW_NNS</a> );
<a name="l00524"></a>00524                 }
<a name="l00525"></a>00525 
<a name="l00526"></a>00526                 <span class="comment">/*</span>
<a name="l00527"></a>00527 <span class="comment">                 * Otherwise, add this point as the next NN and continue.</span>
<a name="l00528"></a>00528 <span class="comment">                 */</span>
<a name="l00529"></a>00529                 kNN[ k   ]       = p-&gt;<a class="code" href="struct__p_queue.html#7530efafe5945a266bf8383ae47c7228">Obj</a>-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[p-&gt;<a class="code" href="struct__p_queue.html#37d972ae0b47b9099e30983131d31916">j</a>];
<a name="l00530"></a>00530                 kNN[ k++ ].<a class="code" href="struct___lgm___octree_data.html#527416adf36035c3ea5799827e7cd8b9">Dist2</a> = p-&gt;<a class="code" href="struct__p_queue.html#fcb495567b98cde535c5239b17681f62">MinDist2</a>; <span class="comment">// save the dist2 into the data struct</span>
<a name="l00531"></a>00531                 *Kgot = k;
<a name="l00532"></a>00532 
<a name="l00533"></a>00533             } <span class="keywordflow">else</span> {
<a name="l00534"></a>00534 
<a name="l00535"></a>00535                 <span class="comment">/*</span>
<a name="l00536"></a>00536 <span class="comment">                 * If the object is cell, then descend one level closer to</span>
<a name="l00537"></a>00537 <span class="comment">                 * the leaf node that is closest to the query point. This also</span>
<a name="l00538"></a>00538 <span class="comment">                 * adds all cells we encounter along the way to the PQ. Ignore</span>
<a name="l00539"></a>00539 <span class="comment">                 * Any cell that is farther than MaxDist2 away from query point.</span>
<a name="l00540"></a>00540 <span class="comment">                 */</span>
<a name="l00541"></a>00541                 <a class="code" href="_lgm___octree_8h.html#9ff86b033bf330695e810d00ac8022e1">DescendTowardClosestLeaf</a>( p-&gt;<a class="code" href="struct__p_queue.html#7530efafe5945a266bf8383ae47c7228">Obj</a>, &amp;PQ, q, MaxDist2 );
<a name="l00542"></a>00542 
<a name="l00543"></a>00543             }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 
<a name="l00546"></a>00546         } <span class="keywordflow">else</span> {
<a name="l00547"></a>00547 
<a name="l00548"></a>00548             <span class="comment">// The priority queue is empy -- there is nothing more to search.</span>
<a name="l00549"></a>00549             done = <a class="code" href="_lgm___c_trans_8h.html#a8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551         }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553         <span class="comment">/*</span>
<a name="l00554"></a>00554 <span class="comment">         * object is no longer needed so free up the space we allocated for it.</span>
<a name="l00555"></a>00555 <span class="comment">         */</span>
<a name="l00556"></a>00556         free( p ); 
<a name="l00557"></a>00557 
<a name="l00558"></a>00558         <span class="keywordflow">if</span> ( k &gt;= K ) done = <a class="code" href="_lgm___c_trans_8h.html#a8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00559"></a>00559 
<a name="l00560"></a>00560     }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562     <span class="comment">/*</span>
<a name="l00563"></a>00563 <span class="comment">     * Free all remaining objects on the PQ</span>
<a name="l00564"></a>00564 <span class="comment">     */</span>
<a name="l00565"></a>00565     <span class="keywordflow">while</span> ( (p = <a class="code" href="_lgm___octree_8h.html#653f08b2912abb5a5fb6c1761b8a8cec">PopObj</a>(&amp;PQ)) ) free( p );
<a name="l00566"></a>00566     
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     <span class="comment">/*</span>
<a name="l00569"></a>00569 <span class="comment">     *  return success</span>
<a name="l00570"></a>00570 <span class="comment">     */</span>
<a name="l00571"></a>00571     <span class="keywordflow">return</span>( <a class="code" href="_lgm___octree_8h.html#9f3b435ad7cc9c098b3de5d62950a1ca">OCTREE_KNN_SUCCESS</a> );
<a name="l00572"></a>00572 
<a name="l00573"></a>00573 }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 
<a name="l00576"></a>00576 
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 
<a name="l00582"></a>00582 
<a name="l00583"></a>00583 
<a name="l00584"></a>00584 
<a name="l00585"></a><a class="code" href="_lgm___octree_8c.html#8faba8ef3514ee1be8aedd369afd4db9">00585</a> <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *<a class="code" href="_lgm___octree_8h.html#8faba8ef3514ee1be8aedd369afd4db9">CreateNewOctants</a>( <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *Parent ) {
<a name="l00586"></a>00586 
<a name="l00587"></a>00587     <span class="keywordtype">int</span>             i;
<a name="l00588"></a>00588     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    xMask, yMask, zMask, BranchBit;
<a name="l00589"></a>00589     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    xParentCode, yParentCode, zParentCode;
<a name="l00590"></a>00590     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    xRight, yRight, zRight, Level;
<a name="l00591"></a>00591     <span class="keywordtype">char</span>            Str[20];
<a name="l00592"></a>00592     <span class="keywordtype">double</span>          xMin, yMin, zMin;
<a name="l00593"></a>00593     <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a>  *Cell;
<a name="l00594"></a>00594 
<a name="l00595"></a>00595     Level     = Parent-&gt;<a class="code" href="struct___lgm___octree_cell.html#a3d2c0758a70c3bb49a3d73a14a94d0a">Level</a> - 1;
<a name="l00596"></a>00596     BranchBit = 1&lt;&lt;Level;
<a name="l00597"></a>00597 
<a name="l00598"></a>00598     <span class="comment">/*</span>
<a name="l00599"></a>00599 <span class="comment">     * allocate 8 cells at once</span>
<a name="l00600"></a>00600 <span class="comment">     */</span>
<a name="l00601"></a>00601     Cell = (<a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *) calloc( 8, <span class="keyword">sizeof</span>( <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> ) );
<a name="l00602"></a>00602 
<a name="l00603"></a>00603     <span class="comment">/*</span>
<a name="l00604"></a>00604 <span class="comment">     * For each cell, set nData = 0</span>
<a name="l00605"></a>00605 <span class="comment">     * Set Parent</span>
<a name="l00606"></a>00606 <span class="comment">     * Set Octant to NULL</span>
<a name="l00607"></a>00607 <span class="comment">     * And determine the x,y,z Location Codes.</span>
<a name="l00608"></a>00608 <span class="comment">     */</span>
<a name="l00609"></a>00609     xMask = 1; yMask = 1&lt;&lt;1; zMask = 1&lt;&lt;2;
<a name="l00610"></a>00610     xParentCode = Parent-&gt;<a class="code" href="struct___lgm___octree_cell.html#068d265e1d6fb7a08db0fd289db2b3ae">xLocationCode</a>;
<a name="l00611"></a>00611     yParentCode = Parent-&gt;<a class="code" href="struct___lgm___octree_cell.html#fd9d41af65e45952ff7a6ec326f8ce86">yLocationCode</a>;
<a name="l00612"></a>00612     zParentCode = Parent-&gt;<a class="code" href="struct___lgm___octree_cell.html#197011505d40af9f13649872c67a61e1">zLocationCode</a>;
<a name="l00613"></a>00613 <span class="comment">//    printf("Parent: Center, h = %g %g %g  %g\n", Parent-&gt;Center.x, Parent-&gt;Center.y, Parent-&gt;Center.z, Parent-&gt;h);</span>
<a name="l00614"></a>00614     <span class="keywordflow">for</span> (i=0; i&lt;8; i++){
<a name="l00615"></a>00615         Cell[i].<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a> = 0;
<a name="l00616"></a>00616         Cell[i].<a class="code" href="struct___lgm___octree_cell.html#4adbef09447a8b0f9932cec8c5e507ee">Parent</a> = Parent;
<a name="l00617"></a>00617         Cell[i].<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a> = NULL;
<a name="l00618"></a>00618 
<a name="l00619"></a>00619         <span class="comment">/*</span>
<a name="l00620"></a>00620 <span class="comment">         * determine if this octant is left or right (i.e. in each coord)</span>
<a name="l00621"></a>00621 <span class="comment">         */</span>
<a name="l00622"></a>00622         xRight = i&amp;xMask;
<a name="l00623"></a>00623         yRight = (i&amp;yMask)&gt;&gt;1;
<a name="l00624"></a>00624         zRight = (i&amp;zMask)&gt;&gt;2;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         Cell[i].<a class="code" href="struct___lgm___octree_cell.html#068d265e1d6fb7a08db0fd289db2b3ae">xLocationCode</a> = ( xRight ) ? xParentCode + BranchBit : xParentCode;
<a name="l00627"></a>00627         Cell[i].<a class="code" href="struct___lgm___octree_cell.html#fd9d41af65e45952ff7a6ec326f8ce86">yLocationCode</a> = ( yRight ) ? yParentCode + BranchBit : yParentCode;
<a name="l00628"></a>00628         Cell[i].<a class="code" href="struct___lgm___octree_cell.html#197011505d40af9f13649872c67a61e1">zLocationCode</a> = ( zRight ) ? zParentCode + BranchBit : zParentCode;
<a name="l00629"></a>00629         Cell[i].<a class="code" href="struct___lgm___octree_cell.html#a3d2c0758a70c3bb49a3d73a14a94d0a">Level</a> = Level;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631         <span class="comment">/*</span>
<a name="l00632"></a>00632 <span class="comment">         * Determine center of cell and width/2 (h=half face width)</span>
<a name="l00633"></a>00633 <span class="comment">         */</span>
<a name="l00634"></a>00634         Cell[i].<a class="code" href="struct___lgm___octree_cell.html#8ee9be1b5aa75abae556de3088cba6d9">h</a> = 0.5*Parent-&gt;<a class="code" href="struct___lgm___octree_cell.html#8ee9be1b5aa75abae556de3088cba6d9">h</a>;
<a name="l00635"></a>00635         Cell[i].<a class="code" href="struct___lgm___octree_cell.html#6db57193d204ce24705e3e95a23bc7c1">Center</a>.<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a> = (double)Cell[i].xLocationCode/(<span class="keywordtype">double</span>)<a class="code" href="_lgm___octree_8h.html#840a13e4ac67b3dece56d79c7ff99b59">OCTREE_MAX_VAL</a> + Cell[i].<a class="code" href="struct___lgm___octree_cell.html#8ee9be1b5aa75abae556de3088cba6d9">h</a>;
<a name="l00636"></a>00636         Cell[i].<a class="code" href="struct___lgm___octree_cell.html#6db57193d204ce24705e3e95a23bc7c1">Center</a>.<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a> = (double)Cell[i].yLocationCode/(<span class="keywordtype">double</span>)<a class="code" href="_lgm___octree_8h.html#840a13e4ac67b3dece56d79c7ff99b59">OCTREE_MAX_VAL</a> + Cell[i].<a class="code" href="struct___lgm___octree_cell.html#8ee9be1b5aa75abae556de3088cba6d9">h</a>;
<a name="l00637"></a>00637         Cell[i].<a class="code" href="struct___lgm___octree_cell.html#6db57193d204ce24705e3e95a23bc7c1">Center</a>.<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a> = (double)Cell[i].zLocationCode/(<span class="keywordtype">double</span>)<a class="code" href="_lgm___octree_8h.html#840a13e4ac67b3dece56d79c7ff99b59">OCTREE_MAX_VAL</a> + Cell[i].<a class="code" href="struct___lgm___octree_cell.html#8ee9be1b5aa75abae556de3088cba6d9">h</a>;
<a name="l00638"></a>00638 <span class="comment">//      printf("Child: Center, h = %g %g %g  %g\n", Cell[i].Center.x, Cell[i].Center.y, Cell[i].Center.z, Cell[i].h);</span>
<a name="l00639"></a>00639 
<a name="l00640"></a>00640 
<a name="l00641"></a>00641 
<a name="l00642"></a>00642 <span class="comment">//        printf("Cell[%d].Center = %g %g %g    h = %g\n", i, Cell[i].Center.x, Cell[i].Center.y, Cell[i].Center.z, Cell[i].h);</span>
<a name="l00643"></a>00643 <span class="comment">//        Binary( Cell[i].xLocationCode, Str ); printf("Index = %d  xLocationCode = %s\n", i, Str);</span>
<a name="l00644"></a>00644 <span class="comment">//        Binary( Cell[i].yLocationCode, Str ); printf("Index = %d  yLocationCode = %s\n", i, Str);</span>
<a name="l00645"></a>00645 <span class="comment">//        Binary( Cell[i].zLocationCode, Str ); printf("Index = %d  zLocationCode = %s\n\n", i, Str);</span>
<a name="l00646"></a>00646 
<a name="l00647"></a>00647     }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649     <span class="keywordflow">return</span>( Cell );
<a name="l00650"></a>00650 
<a name="l00651"></a>00651 }
<a name="l00652"></a>00652 
<a name="l00653"></a>00653 
<a name="l00654"></a><a class="code" href="_lgm___octree_8c.html#3df40f5467250c1b9c2ba1053d38d76f">00654</a> <span class="keywordtype">void</span> <a class="code" href="_lgm___octree_8h.html#3df40f5467250c1b9c2ba1053d38d76f">SubDivideVolume</a>( <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *Vol ) {
<a name="l00655"></a>00655 
<a name="l00656"></a>00656     <span class="keywordtype">int</span>                 Level;
<a name="l00657"></a>00657     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        i, j, BranchBit, xLocationCode, yLocationCode, zLocationCode;
<a name="l00658"></a>00658     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>   ii;
<a name="l00659"></a>00659     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        *Octant;
<a name="l00660"></a>00660     <span class="keywordtype">char</span>                Str[20];
<a name="l00661"></a>00661 
<a name="l00662"></a>00662 
<a name="l00663"></a>00663     <span class="comment">/*</span>
<a name="l00664"></a>00664 <span class="comment">     *  Create 8 new Octant cells</span>
<a name="l00665"></a>00665 <span class="comment">     *  CreateNewOctant() should make nData = 0 as initial value.</span>
<a name="l00666"></a>00666 <span class="comment">     */</span>
<a name="l00667"></a>00667     Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a>  = <a class="code" href="_lgm___octree_8h.html#8faba8ef3514ee1be8aedd369afd4db9">CreateNewOctants</a>( Vol );   
<a name="l00668"></a>00668 
<a name="l00669"></a>00669     <span class="comment">/*</span>
<a name="l00670"></a>00670 <span class="comment">     * Loop through the Data and figure out which </span>
<a name="l00671"></a>00671 <span class="comment">     * octant they belong to. Do this first so we know </span>
<a name="l00672"></a>00672 <span class="comment">     * how much memory we need to allocate to each child's</span>
<a name="l00673"></a>00673 <span class="comment">     * data field.</span>
<a name="l00674"></a>00674 <span class="comment">     */</span>
<a name="l00675"></a>00675     Octant = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *) calloc( Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a>, <span class="keyword">sizeof</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ) );
<a name="l00676"></a>00676     Level = Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#a3d2c0758a70c3bb49a3d73a14a94d0a">Level</a>-1;
<a name="l00677"></a>00677     BranchBit = 1&lt;&lt;Level;
<a name="l00678"></a>00678 <span class="comment">//printf("Level = %d\n", Level);</span>
<a name="l00679"></a>00679 <span class="comment">//printf("BranchBit = %d\n", BranchBit);</span>
<a name="l00680"></a>00680 <span class="comment">//Binary( BranchBit, Str );</span>
<a name="l00681"></a>00681 <span class="comment">//printf("BranchBit = %s\n", Str);</span>
<a name="l00682"></a>00682     <span class="keywordflow">for</span> ( ii=0; ii&lt;Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a>; ii++ ){
<a name="l00683"></a>00683 
<a name="l00684"></a>00684         <span class="comment">// code to find what octant the object is in. Call it j</span>
<a name="l00685"></a>00685         xLocationCode = (<span class="keywordtype">unsigned</span> int)(Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[ii].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a>*<a class="code" href="_lgm___octree_8h.html#840a13e4ac67b3dece56d79c7ff99b59">OCTREE_MAX_VAL</a>);
<a name="l00686"></a>00686         yLocationCode = (<span class="keywordtype">unsigned</span> int)(Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[ii].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a>*OCTREE_MAX_VAL);
<a name="l00687"></a>00687         zLocationCode = (<span class="keywordtype">unsigned</span> int)(Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[ii].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a>*OCTREE_MAX_VAL);
<a name="l00688"></a>00688 <span class="comment">//printf("Vol-&gt;Data[ii].Position.x, Vol-&gt;Data[ii].Position.y, Vol-&gt;Data[ii].Position.z = %g %g %g\n", Vol-&gt;Data[ii].Position.x, Vol-&gt;Data[ii].Position.y, Vol-&gt;Data[ii].Position.z);</span>
<a name="l00689"></a>00689         j = (((xLocationCode &amp; BranchBit) &gt;&gt; Level) + 2*( ((yLocationCode &amp; BranchBit) &gt;&gt; Level) + 2*((zLocationCode &amp; BranchBit) &gt;&gt; Level) ) );
<a name="l00690"></a>00690         Octant[ii] = j;
<a name="l00691"></a>00691         ++(Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a>[j].<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a>);
<a name="l00692"></a>00692 <span class="comment">//printf("%4d: j = %d\n", ii, j);</span>
<a name="l00693"></a>00693 
<a name="l00694"></a>00694     }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696     <span class="comment">/*</span>
<a name="l00697"></a>00697 <span class="comment">     *  Alloc mem to hold the data in each child cell</span>
<a name="l00698"></a>00698 <span class="comment">     */</span>
<a name="l00699"></a>00699     <span class="keywordflow">for</span> ( i=0; i&lt;8; i++ ) {
<a name="l00700"></a>00700 <span class="comment">//        printf("nData = %d\n", Vol-&gt;Octant[i].nData);</span>
<a name="l00701"></a>00701         Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a>[i].<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a> = calloc( Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a>[i].<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a>, <span class="keyword">sizeof</span>( <a class="code" href="struct___lgm___octree_data.html">Lgm_OctreeData</a> ) );
<a name="l00702"></a>00702         Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a>[i].<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a> = 0; <span class="comment">// reset to zero (will recount below)</span>
<a name="l00703"></a>00703     }
<a name="l00704"></a>00704 
<a name="l00705"></a>00705     <span class="comment">/*</span>
<a name="l00706"></a>00706 <span class="comment">     *  Copy the data into the children cells</span>
<a name="l00707"></a>00707 <span class="comment">     */</span>
<a name="l00708"></a>00708     <span class="keywordflow">for</span> ( ii=0; ii&lt;Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a>; ii++ ){
<a name="l00709"></a>00709         j = Octant[ii];
<a name="l00710"></a>00710         Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a>[j].<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[ (Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a>[j].<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a>)++ ] = Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[ii]; 
<a name="l00711"></a>00711         
<a name="l00712"></a>00712     }
<a name="l00713"></a>00713 
<a name="l00714"></a>00714 
<a name="l00715"></a>00715     <span class="comment">/*</span>
<a name="l00716"></a>00716 <span class="comment">     * Zero the Data count in this cell.</span>
<a name="l00717"></a>00717 <span class="comment">     * Free Octant -- not needed anymore.</span>
<a name="l00718"></a>00718 <span class="comment">     * Free memory allocated to Parent data field -- its not a leaf anymore.</span>
<a name="l00719"></a>00719 <span class="comment">     */</span>
<a name="l00720"></a>00720     Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#783709cb5c4b14570bf342099817323d">nDataBelow</a> = Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a>;
<a name="l00721"></a>00721     Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a> = 0;
<a name="l00722"></a>00722     free( Octant ); Octant = NULL;
<a name="l00723"></a>00723     free( Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a> ); Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a> = NULL;
<a name="l00724"></a>00724     
<a name="l00725"></a>00725 
<a name="l00726"></a>00726 
<a name="l00727"></a>00727     <span class="comment">/*</span>
<a name="l00728"></a>00728 <span class="comment">     *  Subdivide if there are too many objects in an octant cell</span>
<a name="l00729"></a>00729 <span class="comment">     */</span>
<a name="l00730"></a>00730     <span class="keywordflow">for</span> ( i=0; i&lt;8; i++ ) {
<a name="l00731"></a>00731         <span class="keywordflow">if</span> ( (Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a>[i].<a class="code" href="struct___lgm___octree_cell.html#a3d2c0758a70c3bb49a3d73a14a94d0a">Level</a> &gt; 0 ) &amp;&amp; (Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a>[i].<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a> &gt; <a class="code" href="_lgm___octree_8h.html#4a40a403f3149048e731aa2c41fcf848">OCTREE_MAX_DATA_PER_OCTANT</a> ) ) <a class="code" href="_lgm___octree_8h.html#3df40f5467250c1b9c2ba1053d38d76f">SubDivideVolume</a>( &amp;(Vol-&gt;<a class="code" href="struct___lgm___octree_cell.html#3a1ad61cfa92956310b1584c5c9ccb80">Octant</a>[i]) );
<a name="l00732"></a>00732     }
<a name="l00733"></a>00733     
<a name="l00734"></a>00734     
<a name="l00735"></a>00735     <span class="keywordflow">return</span>;
<a name="l00736"></a>00736 
<a name="l00737"></a>00737 
<a name="l00738"></a>00738 }
<a name="l00739"></a>00739 
<a name="l00740"></a><a class="code" href="_lgm___octree_8c.html#662a8337622fc6df46766be9249ec872">00740</a> <span class="keywordtype">void</span> <a class="code" href="_lgm___octree_8c.html#662a8337622fc6df46766be9249ec872">Lgm_OctreeScalePoint</a>( <a class="code" href="struct_lgm___vector.html">Lgm_Vector</a> *u, <a class="code" href="struct_lgm___vector.html">Lgm_Vector</a> *v, <span class="keywordtype">double</span> Min, <span class="keywordtype">double</span> Diff ) {
<a name="l00741"></a>00741     v-&gt;<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a> = (u-&gt;<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a> - Min)/Diff;
<a name="l00742"></a>00742     v-&gt;<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a> = (u-&gt;<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a> - Min)/Diff;
<a name="l00743"></a>00743     v-&gt;<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a> = (u-&gt;<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a> - Min)/Diff;
<a name="l00744"></a>00744 }
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 <span class="comment">/*</span>
<a name="l00748"></a>00748 <span class="comment"> * This actually does the work of creating the whole octree</span>
<a name="l00749"></a>00749 <span class="comment"> *</span>
<a name="l00750"></a>00750 <span class="comment"> *  Input:</span>
<a name="l00751"></a>00751 <span class="comment"> *  ------</span>
<a name="l00752"></a>00752 <span class="comment"> *          ObjectPoints - An array of position vectors</span>
<a name="l00753"></a>00753 <span class="comment"> *          ObjectData   - An array of data vectors (e.g. B-field)</span>
<a name="l00754"></a>00754 <span class="comment"> *          N            - Number of ObjectPoints</span>
<a name="l00755"></a>00755 <span class="comment"> *</span>
<a name="l00756"></a>00756 <span class="comment"> *  Output:</span>
<a name="l00757"></a>00757 <span class="comment"> *  -------</span>
<a name="l00758"></a>00758 <span class="comment"> *          Min         - The Min value of all position components</span>
<a name="l00759"></a>00759 <span class="comment"> *          Max         - The Max value of all position components</span>
<a name="l00760"></a>00760 <span class="comment"> *          Min         - Max-Min</span>
<a name="l00761"></a>00761 <span class="comment"> *</span>
<a name="l00762"></a>00762 <span class="comment"> *  Return:</span>
<a name="l00763"></a>00763 <span class="comment"> *  -------</span>
<a name="l00764"></a>00764 <span class="comment"> *          returns a pointer to the root node of the octree</span>
<a name="l00765"></a>00765 <span class="comment"> *</span>
<a name="l00766"></a>00766 <span class="comment"> */</span>
<a name="l00767"></a><a class="code" href="_lgm___octree_8c.html#20080c6b6bf182550e7c1e99d3807020">00767</a> <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a> *<a class="code" href="_lgm___octree_8h.html#20080c6b6bf182550e7c1e99d3807020">Lgm_InitOctree</a>( <a class="code" href="struct_lgm___vector.html">Lgm_Vector</a> *ObjectPoints, <a class="code" href="struct_lgm___vector.html">Lgm_Vector</a> *ObjectData, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> N, <span class="keywordtype">double</span> *Min, <span class="keywordtype">double</span> *Max, <span class="keywordtype">double</span> *Diff ) {
<a name="l00768"></a>00768 
<a name="l00769"></a>00769     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>   j;
<a name="l00770"></a>00770     <a class="code" href="struct___lgm___octree_cell.html">Lgm_OctreeCell</a>      *ot;
<a name="l00771"></a>00771 
<a name="l00772"></a>00772     ot = <a class="code" href="_lgm___octree_8h.html#cf7917181ce8b3f4ceb3f8f6af804889">Lgm_CreateOctreeRoot</a>();
<a name="l00773"></a>00773     ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a>      = N;
<a name="l00774"></a>00774     ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#783709cb5c4b14570bf342099817323d">nDataBelow</a> = ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a>;
<a name="l00775"></a>00775     ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>       = (<a class="code" href="struct___lgm___octree_data.html">Lgm_OctreeData</a> *) calloc( ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a>, <span class="keyword">sizeof</span>( <a class="code" href="struct___lgm___octree_data.html">Lgm_OctreeData</a> ) );
<a name="l00776"></a>00776     *Max = -9e99;
<a name="l00777"></a>00777     *Min = 9e99;
<a name="l00778"></a>00778     <span class="keywordflow">for</span> (j=0; j&lt;ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a>; j++){
<a name="l00779"></a>00779         ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a> = ObjectPoints[j].<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a>;
<a name="l00780"></a>00780         ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a> = ObjectPoints[j].<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a>;
<a name="l00781"></a>00781         ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a> = ObjectPoints[j].<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a>;
<a name="l00782"></a>00782         ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#867ec249dee38c139df965aa1611ed2a">B</a>.<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a> = ObjectData[j].<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a>;
<a name="l00783"></a>00783         ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#867ec249dee38c139df965aa1611ed2a">B</a>.<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a> = ObjectData[j].<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a>;
<a name="l00784"></a>00784         ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#867ec249dee38c139df965aa1611ed2a">B</a>.<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a> = ObjectData[j].<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a>;
<a name="l00785"></a>00785         <span class="comment">/*</span>
<a name="l00786"></a>00786 <span class="comment">         * Find scaling for data</span>
<a name="l00787"></a>00787 <span class="comment">         */</span>
<a name="l00788"></a>00788         <span class="keywordflow">if</span> ( ObjectPoints[j].x &gt; *Max ) *Max = ObjectPoints[j].<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a>;
<a name="l00789"></a>00789         <span class="keywordflow">if</span> ( ObjectPoints[j].y &gt; *Max ) *Max = ObjectPoints[j].<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a>;
<a name="l00790"></a>00790         <span class="keywordflow">if</span> ( ObjectPoints[j].z &gt; *Max ) *Max = ObjectPoints[j].<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a>;
<a name="l00791"></a>00791         <span class="keywordflow">if</span> ( ObjectPoints[j].x &lt; *Min ) *Min = ObjectPoints[j].<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a>;
<a name="l00792"></a>00792         <span class="keywordflow">if</span> ( ObjectPoints[j].y &lt; *Min ) *Min = ObjectPoints[j].<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a>;
<a name="l00793"></a>00793         <span class="keywordflow">if</span> ( ObjectPoints[j].z &lt; *Min ) *Min = ObjectPoints[j].<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a>;
<a name="l00794"></a>00794     }
<a name="l00795"></a>00795 
<a name="l00796"></a>00796     <span class="comment">/*</span>
<a name="l00797"></a>00797 <span class="comment">     * Scale Data (positions need to be in range of [0-1]</span>
<a name="l00798"></a>00798 <span class="comment">     */</span>
<a name="l00799"></a>00799     *Diff = *Max - *Min;
<a name="l00800"></a>00800     <span class="keywordflow">for</span> (j=0; j&lt;ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#c6f35f845cda4fa90dc63051fc4f061a">nData</a>; j++){
<a name="l00801"></a>00801         ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a> = (ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#f88b946fb90d5f08b5fb740c70e98c10">x</a> - *Min)/(*Diff);
<a name="l00802"></a>00802         ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a> = (ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#b927965981178aa1fba979a37168db2a">y</a> - *Min)/(*Diff);
<a name="l00803"></a>00803         ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a> = (ot-&gt;<a class="code" href="struct___lgm___octree_cell.html#173e4af4e76fa34ce187cdf4c913e9d3">Data</a>[j].<a class="code" href="struct___lgm___octree_data.html#5dc98779b36676034ccefe5094251c55">Position</a>.<a class="code" href="struct_lgm___vector.html#b3e6ed577a7c669c19de1f9c1b46c872">z</a> - *Min)/(*Diff);
<a name="l00804"></a>00804     }
<a name="l00805"></a>00805 
<a name="l00806"></a>00806 
<a name="l00807"></a>00807     <a class="code" href="_lgm___octree_8h.html#3df40f5467250c1b9c2ba1053d38d76f">SubDivideVolume</a>( ot );
<a name="l00808"></a>00808 
<a name="l00809"></a>00809     <span class="keywordflow">return</span>( ot );
<a name="l00810"></a>00810 
<a name="l00811"></a>00811 }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813 
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small><a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> </small></address>
</body>
</html>
